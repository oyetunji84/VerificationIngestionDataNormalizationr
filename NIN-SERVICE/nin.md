Perfect. This is exactly the right pause to take.
Before schemas, before Redis tricks, before code â€” we define the rules of money. Once those are clear, the tech becomes obvious.

Iâ€™ll do this in three layers:

Charging policy decisions (business rules)

Technical failure edge cases (network, retries, partial failure)

Concurrency + correctness edge cases (race conditions, double spend)

Iâ€™ll be explicit and opinionated like a senior engineer would be in a design review.

1ï¸âƒ£ Charging policy edge cases (this must be written down)

These are product + legal + trust decisions.

A. NIN does not exist

Example:

Client sends a validly-formatted NIN

Identity service responds: â€œNIN not foundâ€

Options:

âŒ Do NOT charge

Reason: customer got no value

Common in fintech & identity systems

âš ï¸ Charge a reduced fee

You still made an external call

âœ… Charge full fee

Risky for trust unless contract says so

ğŸ‘‰ Industry standard:
Do NOT charge if the NIN does not exist

Reason:

Customers expect to pay for successful identity verification, not lookup failure

You avoid disputes

ğŸ“Œ Recommendation:

Charge only if identity service returns a verified, valid identity

B. Invalid NIN format (client error)

Example:

Wrong length

Non-numeric characters

ğŸ‘‰ Do NOT call identity service
ğŸ‘‰ Do NOT charge

Return:

400 Bad Request

No wallet interaction at all

C. Identity service says â€œtemporarily unavailableâ€

Example:

Timeout

5xx error

Network failure

ğŸ‘‰ Do NOT charge

Reason:

You didnâ€™t get a result

This is your infrastructure problem

D. Identity service returns â€œpartial / inconclusiveâ€

Example:

Data mismatch

Incomplete record

â€œTry again laterâ€

ğŸ‘‰ Do NOT charge
ğŸ‘‰ Log usage but no debit

E. Identity service returns success but downstream fails

Example:

Identity service responds OK

Your DB crashes before debit

This is a critical money edge case (weâ€™ll solve later with transactions + idempotency).

2ï¸âƒ£ Wallet & balance edge cases
F. Wallet balance is exactly equal to cost

Example:

Balance = â‚¦100

Cost = â‚¦100

ğŸ‘‰ Allow request
ğŸ‘‰ After success â†’ balance = â‚¦0

Next request:

Reject with 402 Payment Required or 403 Insufficient Funds

G. Wallet balance < cost

Example:

Balance = â‚¦50

ğŸ‘‰ Reject immediately
ğŸ‘‰ Do NOT call identity service

This saves you money and avoids debt.

H. Wallet is funded while requests are in flight

Example:

Balance = â‚¦0

5 requests rejected

Wallet funded â‚¦10,000

New requests allowed

ğŸ‘‰ Correct behavior
Old rejected requests should not magically retry

I. Wallet goes negative (must NEVER happen)

If this happens:

You have a serious bug

Ledger and balance are inconsistent

We will design to make this mathematically impossible.

3ï¸âƒ£ Network & retry edge cases (very important)
J. Client retries the same request

Example:

Client sends request

Network times out

Client retries

Without idempotency:

You charge twice âŒ

ğŸ‘‰ This is why we must create a request_id

K. Client retries after success

Example:

Identity check succeeded

Debit succeeded

Client never received response

Client retries

ğŸ‘‰ Must return same result
ğŸ‘‰ Must NOT debit again

L. Payment webhook fires twice (funding)

Example:

Paystack sends webhook twice

ğŸ‘‰ Wallet funding must be idempotent
ğŸ‘‰ Same payment reference = only one credit

4ï¸âƒ£ Concurrency & race condition edge cases
M. Two requests at the same time, one balance

Example:

Balance = â‚¦100

Two NIN requests start simultaneously

Both see:

â€œBalance >= 100â€ ğŸ˜¬

Without locking:

Both succeed

Balance becomes -â‚¦100 âŒ

ğŸ‘‰ We must ensure:

Only one request wins

The other fails or waits

N. One request succeeds, one fails

Example:

Request A succeeds â†’ debit

Request B calls identity service but balance is now 0

ğŸ‘‰ Request B must fail before debit
ğŸ‘‰ Preferably fail before calling identity service

O. Identity service is slow

Example:

10 seconds response time

Meanwhile, wallet balance changes

ğŸ‘‰ You cannot â€œreserveâ€ money incorrectly
ğŸ‘‰ Weâ€™ll need a reservation / pending state

5ï¸âƒ£ Accounting & audit edge cases
P. Ledger mismatch

If:

Sum(credits) âˆ’ sum(debits) â‰  wallet.balance

ğŸ‘‰ This is an emergency
ğŸ‘‰ Ledger is king, balance is derived

Weâ€™ll design:

Strong DB constraints

Periodic reconciliation

Q. Manual admin adjustments

Example:

Admin credits wallet

Admin debits wallet (refund, penalty)

ğŸ‘‰ Must go through same ledger
ğŸ‘‰ Never directly edit balance

R. Currency changes (future-proofing)

Today:

Only NGN

Tomorrow:

Multiple currencies

ğŸ‘‰ Even if not now:

Store currency in tables

6ï¸âƒ£ Request identity edge cases (since you said no request_id yet)
S. Same NIN, same company, same second

Is this:

A retry?

A new request?

ğŸ‘‰ You cannot guess

So we will require:

client_request_id (UUID)

Generated by client OR by your gateway

T. Client forgets to send request_id

ğŸ‘‰ Reject request
ğŸ‘‰ Force correctness

7ï¸âƒ£ Summary of charging rule (this should be written in docs)

We charge exactly once, and only when:

The request is valid

Wallet balance is sufficient

Identity service returns a verified success

The request_id has not been charged before

Everything else:
âŒ No charge

Before next step: confirm these 3 decisions

Reply with Yes / No / Change for each:

1ï¸âƒ£ Charge ONLY on verified successful identity (not found = no charge)
2ï¸âƒ£ Every NIN request must include a unique request_id
3ï¸âƒ£ Insufficient balance â†’ reject before calling identity service

Once you confirm, next weâ€™ll:
â¡ï¸ Define request lifecycle states
â¡ï¸ Design exactly-once debit flow
â¡ï¸ Write Postgres schema with constraints
â¡ï¸ Decide where Redis actually helps (and where it must NOT be used)

This is solid thinking. Youâ€™re designing a real billing system, not a toy.


////// from chatgpt 
nior design doc or architecture walkthrough.
No code yet â€” just how the system behaves, why itâ€™s safe, and how we avoid money bugs.

ğŸ¯ Goal (restated clearly)

Build a production-grade billing + wallet system for an existing Node.js identity (NIN) service such that:

Companies pre-fund a wallet

Each successful NIN verification costs money

Billing is:

Correct

Exactly-once

Concurrency-safe

Auditable

System survives:

Retries

Network failures

High parallel traffic

Postgres = source of truth
Redis = performance + coordination helper, never authority

ğŸ§  Core design principles (non-negotiable)

These guide every decision:

Ledger-first accounting

Balance is derived from transactions

No â€œmagic balance updatesâ€

Exactly-once charging

One request â†’ at most one debit

No charge without value

Only charge on verified identity success

No negative balances

Must be mathematically impossible

Idempotency everywhere

Requests, funding, retries

ğŸ§© High-level components

You will add 3 major logical components:

Wallet Service

Billing Engine

Request Lifecycle Manager

These may live in the same codebase, but conceptually they are separate.

1ï¸âƒ£ Wallet model (how money exists)
Entities (conceptually)

Wallet

Owned by a company

One currency (NGN)

Transaction (Ledger Entry)

CREDIT or DEBIT

Immutable

Balance

Cached for speed

Derived from ledger

Golden rule

Never update balance without inserting a transaction

2ï¸âƒ£ Request identity (the foundation of correctness)

Since you confirmed YES to request IDs:

Every NIN request MUST have:

request_id (UUID)

company_id

service_type = NIN_VERIFICATION

This ID represents:

One business action

One possible charge

One ledger outcome

If client doesnâ€™t send it:
âŒ Reject the request

3ï¸âƒ£ Request lifecycle (this is the heart of the system)

Every request moves through explicit states.

Request states
RECEIVED
â†’ VALIDATED
â†’ FUNDS_RESERVED
â†’ IDENTITY_CALLED
â†’ SUCCESS | FAILED
â†’ DEBITED | NOT_CHARGED


You donâ€™t have to store all states physically, but mentally and logically, this flow matters.

4ï¸âƒ£ Exact flow for a NIN verification request
Step 1: Request comes in

Validate:

request_id present

NIN format valid

If invalid â†’ return 400, stop

Step 2: Idempotency check

Check:

â€œHave I seen this request_id before for this company?â€

If yes:

Return the previous result

Do NOT re-charge

Do NOT re-call identity service

This protects against:

Client retries

Network timeouts

Step 3: Pre-check balance (fast path)

Read balance (Redis or Postgres)

If balance < cost:

Reject immediately

Do NOT call identity service

âš ï¸ This is a pre-check, not final authority

Step 4: Reserve funds (critical section)

This is where most systems fail.

You must:

Prevent two requests from spending the same money

Strategy (high-level)

Use Postgres row-level locking

One transaction:

Lock wallet row

Re-check balance

Create a pending debit record tied to request_id

If balance is now insufficient:

Abort

Other request already won

This ensures:

No double spend

No negative balance

Step 5: Call identity service

Outside the DB transaction

Because itâ€™s slow and external

Results:

SUCCESS (verified identity)

FAILURE (not found, timeout, error)

Step 6: Finalize billing
If identity SUCCESS

Convert pending debit â†’ final debit

Mark request as charged

Commit

If identity FAILURE

Cancel pending debit

No charge

Commit

5ï¸âƒ£ Funding the wallet

Funding is just another ledger event.

Rules

Every funding action has:

funding_reference (payment ID)

Funding is idempotent

Flow

Receive funding request / webhook

Check if funding_reference already exists

If yes â†’ ignore

If no:

Insert CREDIT transaction

Update wallet balance

6ï¸âƒ£ Redis: what it does and what it NEVER does
Redis is used for:

Balance caching

Short-lived locks (optional)

Rate limiting

Fast reads

Redis is NOT used for:

âŒ Final balance
âŒ Ledger
âŒ Billing decisions

If Redis goes down:

System still works

Just slower

7ï¸âƒ£ APIs you will expose
Wallet

POST /wallet/fund

GET /wallet/balance

Billing

GET /billing/transactions

GET /billing/usage

Identity

POST /nin/verify

Requires request_id

Enforces billing rules

8ï¸âƒ£ Edge case handling (how we sleep at night)
Scenario	Outcome
Client retries	Same response, no double charge
Two concurrent requests	One wins, one fails
NIN not found	No charge
Identity timeout	No charge
DB crash after success	Request marked pending â†’ retried safely
Webhook fires twice	Single credit
Balance exactly equals cost	Allowed
Balance insufficient	Rejected early
9ï¸âƒ£ Observability & audit (often forgotten)

You will log:

request_id

wallet_id

transaction_id

before_balance / after_balance

identity_response_code

This lets you:

Reconcile money

Resolve disputes

Debug production issues

10ï¸âƒ£ Why this design is safe

âœ” No negative balances
âœ” No double charges
âœ” Retry-safe
âœ” Concurrency-safe
âœ” Auditable
âœ” Matches fintech standards

This is how real payment and billing systems are built.

Next steps (order matters)

If youâ€™re ready, we go step by step:

1ï¸âƒ£ Design database schema (wallets, transactions, requests)
2ï¸âƒ£ Write the exact SQL patterns (locking + constraints)
3ï¸âƒ£ Define idempotency strategy in detail
4ï¸âƒ£ Redis integration plan
5ï¸âƒ£ Failure recovery scenarios

Say â€œStart with schemaâ€ and weâ€™ll design tables like a production system, not a tutorial.
